

# C++

## 右值引用

右值是表达式的中间结果/函数返回值，是将亡值，相比于左值它不能取地址。右值引用只能引用右值，延长了右值的生命周期。右值引用本身却是左值。

引入右值引用，其实是为了移动语义，减少拷贝。std::move就是将左值转为右值引用。

## move

move输入参数类型是万能引用，既可以接收左值，也可以接收右值。这涉及到C++的**型别推导**和**引用折叠**。

```c++
template <typename T>
typename remove_reference<T>::type&& move(T&& t)
{
    return static_cast<typename remove_reference<T>::type&&>(t);
}
```

move什么也移动不了，唯一功能是把左值/右值强制类型转换为右值，让右值引用可以指向左值。

有了移动语义之后，STL和自定义类中就可以定义移动构造函数，移动赋值函数，从而避免拷贝，提升程序性能。

## forward

一般搭配模板，从而实现万能转发。

## volatile

它是被设计用来修饰被不同线程访问和修改的变量。如果没有volatile，基本上会导致这样的结果：要么无法编写多线程程序，要么编译器失去大量优化的机会。

volatile提醒编译器它后面所定义的变量随时都有可能改变，因此程序每次需要存储或读取这个变量的时候不做优化，都会直接从变量内存地址中读取数据，从而可以提供对特殊地址的稳定访问。

如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。

# C++ STL

## C++的六大组件

- 容器。封装了各种数据结构。vector，array，list，deque，set，map。都是类模板。

- 算法。各种常用算法，例如容器初始化，搜索，排序等操作。 通过迭代器和容器（数据结构）解耦合。

- 迭代器。泛型指针，用于遍历容器的元素，扮演算法和容器之间的胶合剂。每个容器都会定义自己的迭代器，迭代器重载了一些运算符，例如自增，自减，随机访问（下标），指向，解引用运算符。这些运算符表明了当前容器的特性，同时也隐藏了容器的实现细节。

- 仿函数（函数对象）。是一种重载了operator()的类模板。作为算法的某种策略（例如升序，降序）

- 分配器。内存管理器，负责内存的分配，释放等操作。内置内存池。

- 适配器。一种用来修饰容器或者仿函数或迭代器接口的东西。例如 STL 提供的 queue 和 stack，就是一种空间配接器，因为它们的底部完全借助于 deque。

  

## C++vector的动态扩容，为何是1.5倍或者是2倍

[面试题：C++vector的动态扩容，为何是1.5倍或者是2倍_vector扩容1.5倍,2倍区别-CSDN博客](https://blog.csdn.net/qq_44918090/article/details/120583540)

当size=capacity时，会触发扩容机制，每次扩容的空间不能太大/太小，否则会造成空间浪费/频繁扩容，效率低下。

经过摊还分析，发现：

- 以等长方式扩容，push_back的平均时间复杂度是O(n)
- 以倍数方式扩容，push_back的平均时间复杂度是O(1)

# C++内存

new底层还是调用operator new

# C++面向对象

## 三大特性

封装，将数据和方法组合在一个类中，封装能够隐藏类内部的实现细节，只暴露出一些接口，通过public，private，protected来实现。

继承，一个类从另一个类获取其属性和方法的过程，减少代码重复，提高代码复用性。

多态，允许不同类的对象使用相同的接口名字，但具有不同的实现特性。主要通过虚函数和抽象基类（含有纯虚函数，不能被实例化）实现。虚函数允许派生类重写基类方法。

## 访问权限

protected，类似于private，但它们可以在派生类中访问。

## 浅拷贝/深拷贝

主要涉及对象的复制。主要区别在于对象中含有指针成员变量。

### 浅拷贝

逐bit的拷贝，对于指针只拷贝指针的值，并不拷贝其指向的内存地址。

编译器默认实现的拷贝构造和拷贝赋值就是浅拷贝。

一般适用于POD数据类。

### 深拷贝

深拷贝不仅复制对象的基本类型成员和指针的值，还复制指针指向的内存地址。

深拷贝需要手动实现拷贝构造和拷贝赋值函数。



## C++多态的实现方式

多态是指，同一个函数/方法在不同对象上具有不同的表现形式。

静态多态：模板函数，编译时决定调用哪个

动态多态：虚函数，纯虚函数。运行时决定调用哪个

### 动态多态

虚函数是指在基类中声明的函数，可以在派生类中重写。

实现多态时，必须通过基类指针/引用调用虚函数。

### 静态多态

模板函数可以根据传递参数的不同类型，自动生成相应类型的函数代码

## this指针

是指向当前对象的指针，在类的成员函数中访问成员变量/成员函数时，编译器会隐式地将当前对象地地址作为this指针传给成员函数。

this指针也可以作为当前对象的引用（函数返回值）。



## static成员变量

类内是声明，静态成员变量需要在类外进行定义和初始化，因为静态成员变量属于整个类，而不是类的特定实例，所以不能在构造函数中初始化（否则会导致每次实例化都会初始化一次）。

如果类外没有定义+初始化，那么就会报错。

```c++
class Foo {
...
static allocator alloc;
...
}

// undefined reference to `version3::Foo::alloc'
```

static成员变量存储在类的静态存储区

但是static const成员变量可以在类内定义并初始化



三类成员函数

- non-virtual fun：不希望子类重新定义它（override），可以继承到子类。
- virtual fun：希望子类重新定义，而且如果不定义也有默认的定义。
- pure virtual fun：希望子类一定重新定义，因为没有默认定义。



### 为什么构造函数不能是虚函数？

构造函数完成之前，vptr是空的，也就无法通过vptr找到虚函数表。

### 虚函数的调用

**当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定**

![image-20240325160717007](面经.assets/image-20240325160717007.png)



# C++对象模型

[图说C++对象模型：对象内存布局详解 - melonstreet - 博客园 (cnblogs.com)](https://www.cnblogs.com/QG-whz/p/4909359.html)

C++对象模型的底层实现机制并未标准化，不同的编译器实现细节不一样。

## 虚函数表

### 多态与虚表

多态，是指在继承层次中，父类的指针可以具有多种形态——当它指向某个子类对象时，通过它能够调用到子类的函数，而非父类函数。

```c++
class Base {     virtual void print(void);    }
class Drive1 :public Base{    virtual void print(void);    }
class Drive2 :public Base{    virtual void print(void);    }
// 如果更规范一些的话，需要加上override，防止写错

Base * ptr1 = new Base; 
Base * ptr2 = new Drive1;  
Base * ptr3 = new Drive2;

ptr1->print(); //调用Base::print()
prt2->print();//调用Drive1::print()
prt3->print();//调用Drive2::print()

```

这是运行时多态，即父指针在程序运行时才能知道所指的真正类型是什么。这种运行时决议，是通过虚函数表来实现的。

### 使用指针访问虚表

一个类定义了虚函数或者其父类有虚函数时，为了支持多态机制，编译器将为该类添加一个虚函数指针（vptr）。vptr一般都放在对象内存布局的第一个位置上。为了保证在多层继承情况下最快得到虚函数表。

```c++
Base b(1000);
int * vptrAdree = (int *)(&b);  
cout << "虚函数指针（vprt）的地址是：\t"<<vptrAdree << endl;
```

vptr指向虚函数表，虚函数表中存储的是一系列虚函数的地址。这些地址的顺序和类中声明的顺序一致。下面代码可以得到虚函数表中第一个虚函数的地址：

```c++
typedef void(*Fun)(void);
Fun vfunc = (Fun)*( (int *)*(int*)(&b));
cout << "第一个虚函数的地址是：" << (int *)*(int*)(&b) << endl;
cout << "通过地址，调用虚函数Base::print()：";
vfunc();
```

## 对象模型概述

在C++中，有两种数据成员：static 和nonstatic,以及三种类成员函数:static、nonstatic和virtual。

### 非继承下的C++对象模型

nonstatic数据成员放在每个对象中，static数据成员和函数都放在类对象之外，而虚函数，通过虚函数表+虚指针来支持。

- 每个类都有一个虚函数表vtbl，虚表中的指针指向该类的每一个虚函数。虚函数表的前面还设置了一个指向type_info的指针，用于支持RTTI（Run Time Type Identification）。
- 每个类对象都拥有一个虚表指针vptr，由编译器来生成。vptr的设定与重置都由类的复制操作来完成。

![image-20240325155742043](面经.assets/image-20240325155742043.png)

```c++
void testBase( Base&p)
{
    cout << "对象的内存起始地址：" << &p << endl;
    cout << "type_info信息:" << endl;
    RTTICompleteObjectLocator str = *((RTTICompleteObjectLocator*)*((int*)*(int*)(&p) - 1));
 
 
    string classname(str.pTypeDescriptor->name);
    classname = classname.substr(4, classname.find("@@") - 4);
    cout <<  "根据type_info信息输出类名:"<< classname << endl;
 
    cout << "虚函数表地址:" << (int *)(&p) << endl;
 
    //验证虚表
    cout << "虚函数表第一个函数的地址：" << (int *)*((int*)(&p)) << endl;
    cout << "析构函数的地址:" << (int* )*(int *)*((int*)(&p)) << endl;
    cout << "虚函数表中，第二个虚函数即print（）的地址：" << ((int*)*(int*)(&p) + 1) << endl;
 
    //通过地址调用虚函数print（）
    typedef void(*Fun)(void);
    Fun IsPrint=(Fun)* ((int*)*(int*)(&p) + 1);
    cout << endl;
    cout<<"调用了虚函数"；
    IsPrint(); //若地址正确，则调用了Base类的虚函数print（）
    cout << endl;
 
    //输入static函数的地址
    p.countI();//先调用函数以产生一个实例
    cout << "static函数countI()的地址：" << p.countI << endl;
 
    //验证nonstatic数据成员
    cout << "推测nonstatic数据成员baseI的地址：" << (int *)(&p) + 1 << endl;
    cout << "根据推测出的地址，输出该地址的值：" << *((int *)(&p) + 1) << endl;
    cout << "Base::getI():" << p.getI() << endl;
 
}

```

## 继承下的C++对象模型

### 单继承

